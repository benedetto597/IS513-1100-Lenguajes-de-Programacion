<!-- Encabezado -->
## IS513 Lenguajes de Programación 
### Edgar Josué Benedetto Godoy
#### edgar.benedetto@unah.hn
#### 20171033802
___
___

<!-- Titulo -->
# Fases y elementos claves de la creación de los lenguajes de programación

<!-- Introducción -->
## Introducción
La facilidad con la que se **compila** y ejecuta código escrito en algún lenguaje de programación es debido a que ha pasado por un proceso de evolución, cambio y mejora, en su mayoría correctamente documentado, a lo largo de los años desde el **primer registro** de un lenguaje de programación en la década de **1950** se han desarrollado distintos tipos, desde generales algo limitados, hasta algunos de uso muy especifico, con lo cual se han clasificado y distribuido a partir de su funcionalidad u orientación.

La aplicación de los lenguajes de programación en la actualidad es extremadamente basta, desde aplicaciones en el área económica como sistemas de facturación, hasta en la medicina como aplicaciones capaces de predecir enfermedades en distintos porcentajes a partir de una foto de una radiografía, con lo que el aprendizaje de los mismos puede ser comparable con la normalidad con la que se aprende un segundo idioma como el inglés. Hoy en día existen proyectos como **generadores de texto(GPT-3)** con sentido y lógica, que llegan a ser capaces de resolver tareas para las cuales nunca fueron entrenados como **generar código** en algún lenguaje en específico, hasta el punto de que dicho generador se defina a si mismo como:
>GPT-3 podría ser la innovación más grande desde Bitcoin.

Otra parte importante de los lenguajes de programación es la forma en la que se **interpreta** por un computador, dado que al final del día los lenguajes de programación están orientados a ser entendidos por una maquina, en este caso la computadora. Para la tarea de interpretar, traducir y ejecutar existen herramientas conocidas como compiladores los cuales están compuestos en su forma más primitiva por distintos analizadores que son los que determinan si lo que se ha escrito es capaz de ser **traducido** y ejecutado.

Las capacidades de lo que podemos crear a partir de los lenguajes de programación son extensas, sorprendentes y aún queda mucho por explorar. [github.com/openai/gpt-3](https://github.com/openai/gpt-3 "Repositorio del generador de texto GPT-3")

___

<!-- Cuerpo -->
## Importancia del estudio de los lenguajes de programación
El estudio de los lenguajes de programación implica una columna fundamental de la actual **revolución informática** que es relativamente nueva pero avanza a pasos agigantados. En universidades y colegios, una de las orientaciones más demandadas son aquellas que tienen que ver con la informática y consecuentemente algunas carreras están completamente direccionadas al aprendizaje y aplicación de los lenguajes de programación, como ejemplo está la Universidad Nacional Autónoma de Honduras que su carrera de ingeniería más demandada es la de **Ingeniería en sistemas**, la cual posee un aproximado de casi 2,000 estudiantes. En la actualidad el salario promedio de los trabajos orientados a la programación solo en Centro América ronda de entre los $600.00 hasta los $1,500.00 en países como México o Colombia los cuales son países punteros tecnológicamente pueden encontrarse salarios que superan los $2,000.00 mensuales, así que es común que algunas personas opten por el estudio de los lenguajes de programación porque son conocimientos bien pagados. En tiempos de crisis financiera, como por ejemplo, las generadas por una guerra, una pandemia o desastres naturales, los empleos que no se ven afectados y es más, puede llegar a aumentar su demanda son los relacionados con los programadores, es decir, estar en la industria como programador implica una seguridad financiera que ninguna otra carrera ofrece.

## Historia de los lenguajes de programación

Elementos historicos más relevantes:
![Elementos historicos importantes](https://drive.google.com/uc?export=view&id=1pSRlAMBHa_Dg5ypdULDKYxq3yBassiyl)

Los lenguajes de programación tienen sus orígenes en la década de 1950 con la creación de FORTRAN, **lenguaje algorítmico** diseñado por un equipo en IBM dirigido por Jhon Bakus. Progresivamente en esa misma década se fueron creando lenguajes para distintas orientaciones como COBOL, el cual está **orientado a los negocios** o ya en la década siguiente llego Basic, el cual es **orientado a la educación** y así a lo largo de los años se crearón lenguajes capaces de realizar tareas particulares o especificas, progresivamente se fue optimizando la forma en la que el lenguaje era capaz de realizar dichas tareas especificas. En el siglo 21 se empezó a desvelar una forma de programar y orientar los lenguajes de programación que haría revolución en todo aquello que ya conocíamos, tan importante y secreto era que en el auge de Apple el cofundador y presidente ejecutivo de Apple Steve Jobs era invitado a reuniones secretas en las que se discutía sobre la **programación orientada a objetos**, lo cual puede llegar a ser inimaginable hoy en día dado que la programación orientada a objetos es hasta impartida en las universidades, el nivel de abstracción que se puede conseguir con dicho paradigma es muy extenso y dado que nuestros límites con la programación recaen en gran medida en la capacidad de abstraer elementos de la realidad y llevarlos a código ejecutable, la programación orientada a objetos llego a resolver una problemática que desencadeno aún más la revolución informática de la actualidad. Línea del tiempo de la implementación de cada lenguaje de programación: 1V0IJo_oDKQy-1Bx46gPEtWjkKTuqVm4Y

![Implementación de cada lenguaje](https://drive.google.com/uc?export=view&id=1dmauUn32o7zV9GkX7Q5M5ZlskRcIBjO-) 
![Implementación de cada lenguaje](https://drive.google.com/uc?export=view&id=16NQlG_9sU72RdCOIo18sF7Qhk7S33EHF)
![Implementación de cada lenguaje](https://drive.google.com/uc?export=view&id=1vWxchwFspZ5PYkLpsNpge9bp8LnEwxWg)

## Clasificación de los lenguajes de programación 
### Lenguajes algorítmicos
Los lenguajes algorítmicos fueron diseñados para **expresar cálculos matemáticos** o simbólicos. Fueron los primeros idiomas de **alto nivel**, es decir que son capaces de aprovechar al máximo los componentes físicos del computador, algunos de ellos son:
* FORTRAN
    * Primer lenguaje algorítmico, desarrollado por IBM.
* ALGOL 
    * Introdujo la **estructura de bloques** donde se pueden contener datos e instrucciones.
* CECEO 
    * Uso de función aplicada a datos.
* C 
    * Comparte con lenguaje ensamblador el poder de explotar todas las características de la arquitectura interna de una computadora.

### Lenguajes orientados a los negocios
* COBOL
    *  Introdujo la **estructura de datos de registro** para tales tareas.
* SQL 
    * Especifica la organización de bases de datos.

### Lenguajes orientadas a la educación
* BASIC
    * Tiene estructuras de datos simples.
* Logo
    * Tenía una sintaxis más convencional que *LISP* y presentaba "Gráficos de tortuga"
* Hypertalk
    * Poseía características de lenguajes orientados a objetos usando una sintaxis simple en ingles.
* Pascal
    * enfatizó el uso ordenado de estructuras de control condicional y en bucle sin sentencias **GOTO**.
    > GOTO: Instrucción de salto incondicional. -Peter Bishop

### Lenguajes orientados a objetos
Se utilizan para la **gestión de programas grandes**, dado que tienen 4 pilares que los hacen tan poderosos:

| Abstracción | Encapsulamiento | Herencia | Polimorfismo |
| :----------- | :------------- | :------ | :----------- |
| Es un proceso de interpretación, análisis y diseño de deconstruir algo que pertenece a la realidad conocida  y enfocarse en las características importantes de una situación u objeto filtrando o ignorando todas las particularidades no esenciales. | Es la agrupación de los componentes abstraídos donde se necesita reconocer cuales se aíslan y cuales no. | Es la obtención de características a partir de una entidad general | Es la propiedad por la que es posible enviar mensajes sintácticamente iguales a objetos de tipos distintos. 

Entre los lenguajes de programación orientados a objetos están: 
* C ++
    * Agrega objetos mientras preserva la eficiencia de los programas de C.
* Ada
    * No estaba orientado a objetos en sus inicios si no hasta Ada 95.
* Java
    * Agregar capacidades interactivas a Internet a través de “applets” web.
* Visual Basic
    * Amplia las capacidades de BASIC agregando objetos y programación **dirigida por eventos**.
    
### Lenguajes de formateo de documentos
Son los encargados de especificar la organización del **texto impreso y los gráficos**.
* Texas
    * Incorpora comandos de formato de texto sin formato en un documento.
* PostScript 
    * Hace uso de postfix, en la que el nombre de una operación sigue sus argumentos.
* SGML
    * Lenguaje de marcado generalizado estándar.

### Lenguajes de visualización de la World Wide Web
* HTML 
    * Lenguaje de marcado de hipertexto
* XML
    * Lenguaje de marcado extensible

### Lenguajes de script 
También conocidos como pequeños lenguajes, son lenguajes que están destinados a **resolver pequeños problemas**, suelen utilizarse para escribir utilidades del sistema operativo como: 
* JavaScript 
    * Adaptado al desarrollo web principalmente del *lado del cliente*.
* PHP
    * Adaptado al desarrollo web principalmente del *lado del servidor*.
* PERL 
    * Lenguaje práctico de extracción e informes 

### Lenguajes Conceptuales
Son lenguajes que no se orientan o desarrollan por un propósito especifico sino que **siguen un concepto** en particular, tienen como característica ser **multi-paradigma** y suelen ser de muy **alto nivel**. 
* PROLOG
    * Lenguaje de programación lógico e interpretado
* LISP
    * Se construye aplicando funciones a argumentos.

## Compiladores 
La compilación hace uso de programas llamados compiladores, los que se encargan de **traducir** lenguajes de programación de alto nivel a **código máquina**. La interpretación se utiliza para sistemas más pequeños que en los traducidos. Aquí es donde entran los **analizadores léxicos**, **sintácticos** y **semánticos**, los cuales son los encargados de la construcción del lenguaje a pequeña escala como el reconocimiento de símbolos admitidos por el lenguaje, las construcción a gran escala como el reconocimiento de expresiones, declaraciones, unidades de programa y por último el reconocimiento de el significado de el conjunto reconocido anteriormente, dichos analizadores funcionan como procesos separados por simplicidad, eficiencia y portabilidad, dado que cada uno de los análisis realiza tareas distintas con lo que se le da de entrada y consecuentemente la salida de uno es la entrada de otro, en el orden de analizadores mencionado.

### Analizador Léxico
Reconocedor de patrones, el cual se encarga de encontrar sub-cadenas en una cadena de caracteres determinada, El analizador léxico recoge personajes en **agrupaciones lógicas** y asigna códigos internos a las agrupaciones, estas agrupaciones lógicas se denominan lexemas. En esencia es un programa que identifica **lexemas**, Los lexemas incluyen: 

* Literales "#"
* Operadores
* Palabras reservadas

Los lenguajes de programación son un conjunto de lexemas y no de caracteres. Los lexemas se dividen:

* Nombres de variables
* Nombres de métodos
* Nombres de clases

El grupo que contiene estos nombres se conoce como identificador de usuario. Cada grupo de lexemas está representado por un nombre o token, el cual representa a dicho grupo. El **token** se define como una categoría de cada grupo de lexemas.
Distintos enfoques para la construcción de los analizadores léxicos orientan al uso de **diagramas de estados**, se utilizan para representar maquinas de estados las cuales especifican la secuencia de estados por las que pasa un objeto a lo largo de su vida en respuesta a evento, donde están los de uso general, los cuales se definen de la siguiente manera: 

Ejemplo de diagrama de estados de una llamada telefónica.

![Diagrama de estados General](https://drive.google.com/uc?export=view&id=1Gco--TgqDIGv23oVz6_6HSnpHUd0gkEy)


1. Estado Inicial: Estado por el cual empieza el diagrama de estados.
2. Estado: Situación en la que se satisface una condición particular.
3. Transición: Es una relación entre dos estados que indica que un objeto que esté en el primer estado realizará ciertas acciones y entrará en el segundo estado cuando ocurra un evento especificado y se satisfagan unas condiciones especificadas.
4. Estado Final: Es donde se terminan las transiciones dado que se consigue un estado de aceptación.

El uso de los diagramas de estado en los compiladores ayuda a la realización de un mapa de todos los caracteres que pueden ser aceptados por el lenguaje. Para lo cual se hace uso de los **autómatas** que utilizan estados y transiciones entre estados en respuesta a las entradas, en donde su concepto radica en leer cada elemento carácter por carácter donde se hace un mapa completo de todos los caracteres, para poder entenderlos en el analizador léxico, luego el analizador sintáctico se hace con **árboles de parseo**, usando conceptos como el diagrama de estados para entender el resto de elementos semánticos, los cuales tienen distintas funcionalidades como ser:

1. Software para diseñar y probar el comportamiento de circuitos digitales.
2. El “analizador léxico” de un compilador típico, es decir, el componente del compilador que separa el texto de entrada en unidades lógicas, tal como identificadores, palabras clave y signos de puntuación.
3. Software para explorar cuerpos de texto largos, como colecciones de páginas web, o para determinar el número de apariciones de palabras, frases u otros patrones.
4. Software para verificar sistemas de todo tipo que tengan un número finito de estados diferentes, tales como protocolos de comunicaciones o protocolos para el intercambio seguro de información.

El **autómata finito** o maquina de estado finito puede ser **determinista** donde solo puede haber para una lectura un único estado o **no determinista** donde puede haber dos estados diferentes para la misma lectura, es decir la diferencia entre estos autómatas es que solo porque existan dos caminos o transiciones de un estado, no significa que lo convierte en no determinista, sino que si de un estado se pudiese concretar una transición haciendo uso del mismo carácter, en ese caso si sería un no determinista, pero al pasar de un estado a otro con distintos caracteres llegando a un solo estado final, queda como determinista. El autómata finito sirve para definir lenguajes, pueden representarse con un diagrama de estados ya que se puede ver como un **grafo direccionado**: 

Ejemplo de una Maquina de estados finitos que acepta un solo estado final.

![Maquina de estado finito](https://drive.google.com/uc?export=view&id=14DUwl3snuSfuPZyjHSjWKjRgSjLztEGr)

Definición formal del Autómata Finito:
Formalmente, un autómata finito es una *quintupla* (Q, Σ, q0, δ, F) donde: 

* *Q* es un conjunto finito de estados.
* *Σ* es un alfabeto finito.
* *q0* es el estado inicial.
* *δ* es una función de transición.
* *F* es un conjunto de estados finales o de aceptación.

### Analizador Sintáctico
Es el que genera la sintaxis, tiene la forma del lenguaje. La salida del analizador léxico es la entrada del analizador sintáctico, y la salida del analizador sintáctico es la entrada del analizador semántico ya que el analizador sintáctico es al que le interesa saber el orden de los componentes. 
No es papel del analizador sintáctico entender las instrucciones, sino solo si el orden es correcto.
En el analizador sintáctico se salta por cada lexema para generar un árbol de parseo, donde con esa estructura se arma la forma en la que reconoce cada token el analizador. Se suelen hacer más de una vuelta al árbol por ejemplo la primera para encontrar errores, la segunda para generar el árbol de parseo y una tercera para definir la tabla de símbolos, etc. Para hacer una sintaxis se necesita hacer una gramática y la capacidad de poder realizar este análisis es también gracias a las **gramáticas independientes de contexto** los cuales utilizan una notación natural recursiva del lenguaje la cual es un conjunto finito de producciones o reglas, siendo conformado por símbolos o por variables, denominado también en ocasiones *símbolos no terminales* o categorías sintácticas, una de las variables representa el lenguaje que se está definiendo; se denomina símbolo inicial. Otras variables representan las clases auxiliares de cadenas que se emplean para definir el lenguaje del símbolo inicial, que forman las cadenas del lenguaje que se está definiendo. La gramática es el método formal para describir una sintaxis; Los lenguajes son identificados a través de nuestros lenguajes de programación por una gramática que la definimos gracias a la gramática libre contexto o  la forma Backus-Naur que son exactamente lo mismo. 
* *Gramática libre de contexto*: Ayuda a definir la posición de los elementos de los lenguajes de programación.
* *Gramática regular*: Ayuda a definir los tokens.

El **árbol de parseo** es el resultado que proporciona el analizador sintáctico de un lenguaje de programación y es la forma en la que se suele representar la estructura de los programas, siendo está estructura de datos una colecciones de nodos, que mantienen una relación padre-hijo, donde existe un nodo, el nodo raíz, que no tiene padre; este nodo aparece en la parte superior del árbol; los nodos sin hijos se denominan hojas. Al concatenar las hojas del árbol de izquierda a derecha(dependiendo de su construcción) se obtienen cadenas denominadas resultados del árbol. 

### Analizador Semántico
Recibe el resultado del análisis sintáctico con lo cual ya se puede asignar un significado a todos los componentes reconocidos correctamente en los análisis previos. Es en esta etapa donde se utiliza como entrada el árbol sintáctico detectado por el análisis sintáctico para comprobar restricciones de tipo y otras limitaciones semánticas y preparar la generación de código.En **compiladores de un solo paso**, las llamadas a las rutinas semánticas se realizan directamente desde el analizador sintáctico y son dichas rutinas las que llaman al generador de código, las cuales hacen uso de la **pila semántica** que contiene la información semántica asociada a los operandos y a veces a los operadores en forma de registro semántico. El instrumento más utilizado para conseguirlo es la gramática de atributos.

En compiladores de dos o más pasos, el análisis semántico se realiza independientemente de la generación de código, pasándose información a través de un archivo intermedio, que normalmente contiene información sobre el árbol sintáctico en forma lineal.

Un componente importante del análisis semántico es la **verificación de tipos**. Aquí, el compilador verifica si cada operador tiene operandos permitidos por la especificación del lenguaje fuente. Por ejemplo, las definiciones de muchos lenguajes de programación requieren que el compilador indique un error cada vez que se use un número real como índice de una matriz. Sin embargo, la especificación del lenguaje puede imponer restricciones a los operandos, por ejemplo, cuando un operador aritmético binario se aplica a un número entero y a un número real, revisa que los arreglos tengan definido el tamaño correcto.

___
<!-- Conclusiones -->
## Conclusiones

1. Los lenguajes de programación son un área de estudio cuanto menos apasionante y de interés masivo, teniendo en cuenta las estadísticas relacionadas con salarios en dicho rubro, es fácil de identificar que más de uno concreta su acercamiento a carreras relacionadas con la idea de simplemente generar una estabilidad económica, lo cual no es un acercamiento erróneo pero si quizá un acercamiento desaprovechado, dado que el conjunto de conocimientos que se necesitan adquirir para llegar a profesionalizarse en este rubro incita a un despliegue de creatividad e innovación, con lo que también es normal encontrar genios en el área, dando como resultado un rubro enriquecido por todas las partes que lo componen y hacen de este un apasionante camino a recorrer.

2. La historia de los lenguajes de programación sigue siendo un relato corto, dado que aún no se concreta ni un siglo desde su primer aparecimiento, pero no obstante la velocidad de su avance no es equivalente a su tiempo en los libros de historia; la revolución informática se ha desencadenado con una aceleración creciente casi exponencial, donde el software ha liderado con sistemas embebidos, Inteligencia artificial, etc. Dando como resultado una variada colección de programas y aplicaciones capaces de resolver problemas tan complejos como simples; también puede verse este avance en su apartado físico, como con la **ley de Moore** que expresa que: 
> Aproximadamente cada dos años se duplica el número de transistores en un microprocesador. - Moore, Gordon E. 

3. La variedad de lenguajes de programación que existen en la actualidad permiten al programador escoger de forma adecuada la opción más optima para la tarea a realizar, dado que se han desarrollado lenguajes de programación de objetivo especifico  como Logo para niños, Verilog y VHSIC, R y S para estadísticas, Mata para programación matricial, Mathematica y Maxima para matemáticas, fórmulas de hojas de cálculo y macros, SQL para consultas a bases de datos relacionales, Yacc para crear parseadores, expresiones regulares para crear análisis léxico, Generic Eclipse Modeling System para crear lenguajes con el objetivo de diagramar, Csound un lenguaje para síntesis digital, y los lenguajes de entrada de GraphViz y GrGen, paquetes de software usados para graficar y reescribir gráficas. Otros lenguajes de propósito general como C o Java son a los que lo largo de los años se han optimizado en el apartado de su compilación, por lo tanto la mayoría de los problemas que se puedan presentar en la actualidad pueden cubrirse con un lenguaje de propósito general o sino con alguno de dominio especifico.

4. La tarea realizada por el compilador representa una parte fundamental de que en la actualidad el trabajo de ejecutar un programa resulte tan sencillo y en muchas ocasiones casi inmediato, por lo tanto es importante conocer la forma en la que se compone cada una de sus partes, la forma en la que desestructura y estructura el código de entrada; teniendo en cuenta que dichos componentes pueden estar integrados o por separado, comúnmente el análisis léxico está separado del sintáctico por la optimización de recursos dado que la forma en la que operan los mismos datos es completamente distinta.

5. Las estructuras de datos fundamentales, como pilas y árboles son aprovechados al máximo en el proceso que ejecutan los compiladores, dado que son estructuras extremadamente flexibles, en especial la estructura de los árboles que desde sus inicios es utilizada para el pareseo de lenguajes. Por lo tanto el conocimiento previo sobre estructuras de control y estructuras de datos es un requisito necesario para adentrarse en los lenguajes de programación.

___

## Bibliografía

* Robert W. Sebesta, University of Colorado at Colorado Springs "Conceptos de Lenguajes de Programación, 10ma Edición".
* John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman. "Introducción a la computación, lenguajes y teoría de los autómatas 2da Edición".
* Michael L. Scott " Programming Language Pragmatics 2nd  Edition".
* Wagner, Ferdinand; Schmuki, Ruedi; Wagner, Thomas; Wolstenholme, Peter "Modeling Software with Finite State Machines: A Practical Approach 1th Edition".
* Dick Grune, Kees van Reeuwijk, Henri E. Bal, Ceriel J.H. Jacobs, Koen Langendoen"Modern Compiler Design 2nd Edition".
___
___








